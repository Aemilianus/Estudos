---
title: "Modelos Lineares Generalizados"
author: "Felipe Fenelon"
date: "27 de agosto de 2025"
output:
  html_document:
    self_contained: false
---

```{r pacotes, message=FALSE, warning=FALSE, include=FALSE}
##Pacotes necess√°rios
library(ggplot2)
library(dplyr)
library(caret)
library(mlbench)
library(corrplot)
library(pROC)
```

# Modelagem Preditiva para Diagn√≥stico de C√¢ncer de Mama

Este reposit√≥rio documenta o desenvolvimento de um modelo de Machine Learning para classificar tumores de mama como benignos ou malignos. O projeto foi conduzido com foco em rigor estat√≠stico, interpretabilidade e valida√ß√£o robusta.

**[‚¨ÖÔ∏è Voltar para o Portf√≥lio Principal](https://aemilianus.github.io/Estudos/)**

---

## üéØ Objetivo
O objetivo central foi construir um modelo estat√≠stico robusto e interpret√°vel capaz de prever a malignidade de um tumor com alta acur√°cia.

## üõ†Ô∏è Metodologia
O projeto foi dividido em etapas claras, simulando um fluxo de trabalho profissional:

* **An√°lise Explorat√≥ria de Dados (EDA)**

* **Engenharia de Atributos e Pr√©-processamento**

* **Modelagem Comparativa (Logit, Probit, Cauchit)**

* **Valida√ß√£o Rigorosa e Sele√ß√£o do Modelo Final**

## üìà Resultados Principais
O modelo Logit final alcan√ßou uma performance excelente no ambiente de teste:

* **AUC:** **0.9876**

* **Acur√°cia:** **92.3%**

---

# An√°lise e Prepara√ß√£o dos Dados
## Sobre a Base de Dados
O conjunto de dados BreastCancer cont√©m informa√ß√µes de relat√≥rios cl√≠nicos de pacientes, fornecidos periodicamente pelo Dr. Wolberg. Embora n√£o haja atualiza√ß√µes desde 1992, os dados compreendem o per√≠odo de janeiro de 1989 a novembro de 1991.
O data frame original possui 699 observa√ß√µes e 11 vari√°veis. Com exce√ß√£o da vari√°vel de identifica√ß√£o (Id) e da vari√°vel resposta (Class), as demais foram convertidas para uma escala ordinal de 1 a 10. Para esta an√°lise, a coluna de Id foi removida, pois n√£o agrega valor preditivo ao modelo.
```{r leitura_dados}
#Leitura da base de dados
data(BreastCancer)
# Excluindo ID, pois de nada serve
cancer_subset1 <- BreastCancer[,-1]
# Estrutura inicial dos dados
str(cancer_subset1)
```

## Dicion√°rio de Vari√°veis

Aqui est√° uma breve descri√ß√£o do significado de cada vari√°vel preditora, interpretada no contexto do diagn√≥stico de c√¢ncer de mama:

* Cl.thickness (Espessura do Aglomerado): C√©lulas epiteliais da mama podem se agrupar. Em tumores, esses aglomerados tendem a ser mais espessos e desorganizados. Um valor alto pode ser um sinal de malignidade.

* Cell.size (Uniformidade do Tamanho da C√©lula): Avalia a varia√ß√£o no tamanho das c√©lulas. C√©lulas cancer√≠genas frequentemente exibem pleomorfismo (grande varia√ß√£o de tamanho), enquanto c√©lulas benignas s√£o mais uniformes.

* Cell.shape (Uniformidade do Formato da C√©lula): Similar √† anterior, mas focada no formato. C√©lulas malignas perdem sua forma regular e se tornam mais irregulares. √â esperado que esta vari√°vel seja altamente correlacionada com Cell.size.

* Marg.adhesion (Ades√£o Marginal): Mede a capacidade de ades√£o das c√©lulas entre si. A perda de ades√£o √© uma caracter√≠stica de c√©lulas cancer√≠genas, relacionada √† sua capacidade de invadir outros tecidos e causar met√°stases.

* Epith.c.size (Tamanho da C√©lula Epitelial Individual): Mede o tamanho de c√©lulas epiteliais que n√£o est√£o em aglomerados. Em c√©lulas malignas, o n√∫cleo tende a aumentar, "esticando" a c√©lula e aumentando seu tamanho geral. √â prov√°vel que seja correlacionada com Cell.size.

* Bare.nuclei (N√∫cleos Nus): Refere-se a n√∫cleos vistos na amostra sem o citoplasma ao redor. O citoplasma de c√©lulas malignas √© mais fr√°gil e tende a se romper durante a prepara√ß√£o da l√¢mina, resultando em "n√∫cleos nus", um forte indicador de malignidade.

* Bl.cromatin (Cromatina Branda): Descreve a textura da cromatina (complexo de DNA e prote√≠nas). Em c√©lulas malignas, a cromatina se agrupa de forma grosseira e irregular, diferente do aspecto "brando" e suave em c√©lulas normais.

* Normal.nucleoli (Nucl√©olos Normais): Avalia a proemin√™ncia dos nucl√©olos. Em c√©lulas cancer√≠genas, que possuem alta atividade de s√≠ntese, os nucl√©olos se tornam maiores e mais f√°ceis de visualizar.

* Mitoses (Mitoses): Conta a quantidade de c√©lulas em processo de divis√£o celular na amostra. Como o c√¢ncer √© uma doen√ßa de prolifera√ß√£o celular descontrolada, um n√∫mero elevado de mitoses √© um indicador chave de malignidade.

* Class (Classe): A vari√°vel resposta de interesse, que classifica a amostra como benign (benigna) ou malignant (maligna). O principal interesse cl√≠nico √© prever a classe malignant com a maior precis√£o e sensibilidade poss√≠vel.

#Divis√£o da Base em Treino e Teste
A base de dados foi dividida em um conjunto de treino (70%) e um de teste (30%). A divis√£o foi estratificada pela vari√°vel Class para garantir que a propor√ß√£o de casos benignos e malignos seja a mesma em ambos os conjuntos, o que √© crucial para a valida√ß√£o do modelo.

```{r divisao_dados}
set.seed(123)
trainIndex <- createDataPartition(cancer_subset1$Class, p = 0.7, list = FALSE)
treino <- cancer_subset1[trainIndex, ]
teste <- cancer_subset1[-trainIndex, ]
#Verificando a propor√ß√£o em cada conjunto
prop.table(table(treino$Class))
prop.table(table(teste$Class))
```
# An√°lise Explorat√≥ria e Engenharia de Atributos

Esta se√ß√£o detalha a an√°lise explorat√≥ria realizada exclusivamente na base de treino para guiar o pr√©-processamento e a cria√ß√£o de novas vari√°veis (engenharia de atributos).

## Investiga√ß√£o de Vari√¢ncia
A fun√ß√£o nearZeroVar do pacote caret foi utilizada para identificar vari√°veis com vari√¢ncia muito baixa ou nula, que geralmente possuem pouco poder preditivo.
```{r nzv}
nzv_report <- nearZeroVar(treino, saveMetrics = TRUE)
print(nzv_report)
```
Apenas a vari√°vel Mitoses se aproximou de ser considerada de vari√¢ncia quase nula, com a categoria mais frequente ("1") aparecendo mais de 15 vezes para cada ocorr√™ncia da segunda mais frequente. Isso indica um forte desbalanceamento. O gr√°fico de barras abaixo ajuda a visualizar essa rela√ß√£o.
```{r plot_mitoses, fig.cap="Distribui√ß√£o da vari√°vel Mitoses por Classe."}
ggplot(data = treino, aes(x = Mitoses, fill = Class)) +
geom_bar(position = "dodge") +
labs(
title = "Distribui√ß√£o da Atividade de Mitoses por Classe",
subtitle = "A maioria das amostras apresenta baixo √≠ndice de Mitoses",
x = "√çndice de Mitoses",
y = "Contagem de Amostras",
fill = "Diagn√≥stico"
) +
scale_fill_manual(values = c("benign" = "#4A74F3", "malignant" = "#B55CE6")) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
)
```
Apesar do desbalanceamento, o gr√°fico mostra que, embora existam muitos casos malignos com mitose = 1, valores maiores que 1 s√£o quase que exclusivamente malignos. Isso sugere que agrupar a vari√°vel em duas categorias ("LOW" e "HIGH") pode ser uma boa idea.
## An√°lise de Correla√ß√£o
Para investigar a rela√ß√£o entre as vari√°veis preditoras, foi gerada uma matriz de correla√ß√£o de Spearman.
```{r funcao_corr, echo=FALSE}
correlation_matrix <- function(tabela, titulo){
cor_tabela = cor(tabela, method = "spearman", use = "complete.obs")
corrplot(cor_tabela,
method = "color",
type = "upper",
order = "hclust",
addCoef.col = "black",
tl.col = "black", tl.srt = 45,
diag = FALSE,
title = titulo,
mar=c(0,0,1,0))
}
```
```{r cor_geral, fig.cap="Correla√ß√£o de Spearman entre todas as vari√°veis preditoras."}
data_for_cor <- treino %>%
mutate(across(Cl.thickness:Mitoses, ~as.numeric(as.character(.)))) %>%
select(-c(Class))
correlation_matrix(data_for_cor, "Matriz de Correla√ß√£o Geral")
```
O correlograma geral revela uma forte correla√ß√£o positiva entre quase todas as vari√°veis. Notavelmente, Cell.size e Cell.shape possuem uma correla√ß√£o de 0.91, indicando alta colinearidade e sugerindo que uma delas deveria ser removida.
Para uma an√°lise mais profunda, as correla√ß√µes foram analisadas separadamente para cada classe (benign e malignant).
```{r cor_split, fig.cap="Correla√ß√£o de Spearman para as classes Benigna (esquerda) e Maligna (direita)."}

# Preparando dados
data_for_cor_bening <- subset(treino, Class == "benign") %>%
mutate(across(Cl.thickness:Mitoses, ~as.numeric(as.character(.)))) %>%
select(-c(Class))
data_for_cor_malig <- subset(treino, Class == "malignant") %>%
mutate(across(Cl.thickness:Mitoses, ~as.numeric(as.character(.)))) %>%
select(-c(Class))

# Plotando
correlation_matrix(data_for_cor_bening, "Correla√ß√£o na Classe Benigna")
correlation_matrix(data_for_cor_malig, "Correla√ß√£o na Classe Maligna")

```
A an√°lise separada revela que as rela√ß√µes entre as vari√°veis mudam dependendo da classe. A correla√ß√£o entre Cell.size e Cell.shape continua alta em ambos os grupos. Curiosamente, a vari√°vel Cl.thickness demonstra um comportamento de intera√ß√£o: ela possui correla√ß√µes mais fracas no grupo benigno e mais fortes no grupo maligno, sugerindo que seu papel muda quando a malignidade est√° presente.

## Gr√°ficos de Barras entre covari√°veis e Class
```{r}

# Agora, podemos avaliar o comportamento das outras vari√°veis restantes frente a
# vari√°vel resposta

# Vetor que acumula os nomes que n√£o s√£o as que n√£o quero fazer gr√°ficos.
variaveis_para_plotar <-
  names(treino)[!names(treino) %in% c("Mitoses_grouped", "Class")]

# Loop para criar e imprimir um gr√°fico para cada vari√°vel
for (variavel in variaveis_para_plotar) {
  
  # Criar o gr√°fico
  p <- ggplot(treino, aes_string(x = variavel, fill = "Class")) +
    geom_bar(position = "dodge") +
    labs(
      title = paste("Distribui√ß√£o de", variavel, "por Classe"),
      x = variavel,
      y = "Frequ√™ncia"
    ) +
    scale_fill_manual(values = c("benign" = "#4A74F3", "malignant" = "#B55CE6")) +
    theme_minimal()
  
  # Imprimir o gr√°fico no painel de Plots
  print(p)
}
```

## Pr√©-processamento
Com base na an√°lise explorat√≥ria, as seguintes decis√µes de pr√©-processamento foram tomadas:

1. Remo√ß√£o de Vari√°vel: A vari√°vel Cell.shape foi removida para mitigar a forte colinearidade com Cell.size.

2. Agrupamento de Vari√°veis (Binariza√ß√£o): As vari√°veis Mitoses, Cell.size, Epith.c.size, Bare.nuclei e Normal.nucleoli mostraram um padr√£o de "degrau", onde valores baixos (frequentemente apenas o n√≠vel 1) estavam associados √† classe benigna, e valores maiores indicavam malignidade. Elas foram agrupadas em categorias "Low" e "High".

3. Agrupamento em Tr√™s N√≠veis: A vari√°vel Bl.cromatin mostrou um comportamento mais complexo, com os n√≠veis 1-2 sendo majoritariamente benignos, o n√≠vel 3 sendo misto, e os n√≠veis >3 sendo majoritariamente malignos. Ela foi agrupada em "Low", "Medium" e "High".

4. Imputa√ß√£o de Dados Faltantes: A vari√°vel Bare.nuclei possu√≠a valores faltantes (NA). Como a maioria dos casos nesta coluna pertence √† classe "1" (que tamb√©m √© a moda da classe benigna), os valores ausentes foram imputados com o valor 1.

5. Manuten√ß√£o como Num√©rica: As vari√°veis Cl.thickness e Marg.adhesion mostraram uma progress√£o mais gradual do risco e foram mantidas como num√©ricas para que o modelo pudesse capturar essa rela√ß√£o.

As transforma√ß√µes foram aplicadas de forma id√™ntica aos conjuntos de treino e teste.
```{r engenharia_atributos}
# Retirando cell.shape
treino <- treino %>% select(-Cell.shape)
teste <- teste %>% select(-Cell.shape)
# Fun√ß√£o para aplicar todas as regras de engenharia de atributos
aplicar_engenharia_de_atributos <- function(dataframe){
dataframe_eng <- dataframe %>%
mutate(
# Agrupar Mitoses em Low/High
Mitoses_grouped = factor(ifelse(Mitoses == "1", "Low", "High"), levels = c("Low", "High")),
# Agrupar Cell.size em Low/High
Cell.size_grouped = factor(
ifelse(as.numeric(as.character(Cell.size)) <= 2, "Low", "High"), levels = c("Low", "High")
),
# Agrupar Epith.c.size em Low/High
Epith.c.size_grouped = factor(
ifelse(as.numeric(as.character(Epith.c.size)) <= 2, "Low", "High"), levels = c("Low", "High")
),
# Imputar NA e Agrupar Bare.nuclei em Low/High
temp_bare_nuclei_num = as.numeric(as.character(Bare.nuclei)),
temp_bare_nuclei_num = ifelse(is.na(temp_bare_nuclei_num), 1, temp_bare_nuclei_num),
Bare.nuclei_grouped = factor(
ifelse(temp_bare_nuclei_num <= 1, "Low", "High"), levels = c("Low", "High")# Usando <= 1  para ser mais robusto
),
# Agrupar Normal.nucleoli em Low/High
Normal.nucleoli_grouped = factor(
ifelse(as.numeric(as.character(Normal.nucleoli)) <= 1, "Low", "High"), levels = c("Low", "High") # Usando <= 1
),
# Agrupar Bl.cromatin em Low/Medium/High
Bl.cromatin_grouped = factor(
case_when(
as.numeric(as.character(Bl.cromatin)) <= 2 ~ "Low",
as.numeric(as.character(Bl.cromatin)) == 3 ~ "Medium",
as.numeric(as.character(Bl.cromatin)) > 3 ~ "High"
),
levels = c("Low", "Medium", "High")
),
# Converter vari√°veis num√©ricas
Marg.adhesion_Numeric = as.numeric(as.character(Marg.adhesion)),
Cl.thickness_Numeric = as.numeric(as.character(Cl.thickness))
) %>%
select(-temp_bare_nuclei_num) # Remove a coluna tempor√°ria
return(dataframe_eng)
}
# Aplicando as transforma√ß√µes
treino_eng <- aplicar_engenharia_de_atributos(treino)
teste_eng <- aplicar_engenharia_de_atributos(teste)
# Definindo a classe de refer√™ncia para a resposta e os preditores
treino_eng$Class <- relevel(treino_eng$Class, ref = "benign")
teste_eng$Class <- relevel(teste_eng$Class, ref = "benign")
# Verificando a estrutura final do dataframe de treino
str(treino_eng)
```
# Ajuste e Avalia√ß√£o dos Modelos
Com os dados devidamente preparados, foram ajustados tr√™s Modelos Lineares Generalizados (GLM) para dados bin√°rios, cada um com uma fun√ß√£o de liga√ß√£o diferente: Logit, Probit e Cauchit.

## Modelos Completos e Simplificados
Inicialmente, foram ajustados modelos com todas as vari√°veis preditoras criadas. O modelo com a fun√ß√£o cauchit n√£o convergiu, um sinal de instabilidade possivelmente causado por separa√ß√£o nos dados. As vari√°veis Mitoses_grouped, Epith.c.size_grouped e Normal.nucleoli_grouped se mostraram n√£o significativas na presen√ßa das outras.
Para criar modelos mais simples e robustos (parcimoniosos), essas tr√™s vari√°veis foram removidas. Os modelos resultantes (_2) mostraram melhora no Crit√©rio de Informa√ß√£o de Akaike (AIC) e o modelo cauchit passou a convergir.
```{r modelos_simplificados}
# --- Modelos Simplificados (Vencedores da etapa anterior) ---
#Logito
fit_logit_2 <- glm(Class ~ Cl.thickness_Numeric + Marg.adhesion_Numeric +
Cell.size_grouped + Bare.nuclei_grouped + Bl.cromatin_grouped,
data = treino_eng,
family = binomial(link = "logit"))
#Probito
fit_probit_2 <- glm(Class ~ Cl.thickness_Numeric + Marg.adhesion_Numeric +
Cell.size_grouped + Bare.nuclei_grouped + Bl.cromatin_grouped,
data = treino_eng,
family = binomial(link = "probit"))
# Cauchito
fit_cauchit_2 <- glm(Class ~ Cl.thickness_Numeric + Marg.adhesion_Numeric +
Cell.size_grouped + Bare.nuclei_grouped + Bl.cromatin_grouped,
data = treino_eng,
family = binomial(link = "cauchit"))
# Resumo do modelo Logit simplificado (o melhor no treino segundo o AIC)
summary(fit_logit_2)
```
## Investiga√ß√£o de Intera√ß√£o
Foi testado um modelo adicional com um termo de intera√ß√£o entre Cl.thickness_Numeric e Cell.size_grouped, como sugerido pela an√°lise de correla√ß√£o. O termo de intera√ß√£o n√£o se mostrou estatisticamente significativo (p > 0.05) e o AIC do modelo com intera√ß√£o (93.996) foi maior que o do modelo simples (92.391). Portanto, o modelo mais simples (fit_logit_2) foi mantido como o melhor candidato para a fun√ß√£o de liga√ß√£o logit.

## Compara√ß√£o Visual das Curvas dos Modelos
O gr√°fico abaixo visualiza as probabilidades previstas pelos tr√™s modelos simplificados em fun√ß√£o do seu preditor linear. Isso ilustra as diferentes formas como cada fun√ß√£o de liga√ß√£o mapeia a "evid√™ncia" combinada dos preditores em uma probabilidade de 0 a 1.
```{r plot_curvas, fig.cap="Curvas de probabilidade estimada para os modelos Logit, Probit e Cauchit."}
plot_data <- treino_eng %>%
mutate(
Class_numeric = ifelse(Class == "malignant", 1, 0),
preditor_linear_logit = predict(fit_logit_2, type = "link"),
probabilidade_logit = predict(fit_logit_2, type = "response"),
preditor_linear_probit = predict(fit_probit_2, type = "link"),
probabilidade_probit = predict(fit_probit_2, type = "response"),
preditor_linear_cauchit = predict(fit_cauchit_2, type = "link"),
probabilidade_cauchit = predict(fit_cauchit_2, type = "response")
)
plot_data_curves <- plot_data %>% arrange(preditor_linear_logit)
ggplot() +
geom_jitter(data = plot_data, aes(x = preditor_linear_logit, y = Class_numeric),
width = 0, height = 0.05, alpha = 0.3, color = "gray50") +
geom_line(data = plot_data_curves, aes(x = preditor_linear_logit, y = probabilidade_logit, color = "Logit"), linewidth = 1.2) +
geom_line(data = plot_data_curves, aes(x = preditor_linear_probit, y = probabilidade_probit, color = "Probit"), linewidth = 1.2) +
geom_line(data = plot_data_curves, aes(x = preditor_linear_cauchit, y = probabilidade_cauchit, color = "Cauchit"), linewidth = 1.2) +
scale_color_manual(
name = "Fun√ß√£o de Liga√ß√£o",
values = c("Logit" = "#2649B2", "Probit" = "#4A74F3", "Cauchit" = "#B55CE6")
) +
labs(
title = "Compara√ß√£o das Curvas Estimadas pelas Fun√ß√µes de Liga√ß√£o",
subtitle = "Modelos ajustados com o conjunto de preditores simplificado",
x = "Preditor Linear (Escala Logit)",
y = "Probabilidade Prevista de ser Maligno"
) +
coord_cartesian(xlim = c(-12, 12)) +
ylim(0, 1) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)
)
```
# Avalia√ß√£o Final e Conclus√£o
A etapa final consiste em avaliar o desempenho dos tr√™s modelos simplificados no conjunto de teste, que cont√©m dados que os modelos nunca viram antes.

## Desempenho no Conjunto de Teste
A performance foi medida usando a √Årea Sob a Curva ROC (AUC), uma m√©trica que avalia a capacidade geral de discrimina√ß√£o do modelo, e a Matriz de Confus√£o, que detalha os tipos de acertos e erros.
```{r avaliacao_teste}
# Previs√£o das probabilidades na base de teste
prob_logit <- predict(fit_logit_2, newdata = teste_eng, type = "response")
prob_probit <- predict(fit_probit_2, newdata = teste_eng, type = "response")
prob_cauchit <- predict(fit_cauchit_2, newdata = teste_eng, type = "response")
# C√°lculo da AUC
auc_logit <- auc(teste_eng$Class, prob_logit, quiet = TRUE)
auc_probit <- auc(teste_eng$Class, prob_probit, quiet = TRUE)
auc_cauchit <- auc(teste_eng$Class, prob_cauchit, quiet = TRUE)
print(paste("AUC no Teste - Logit:", round(auc_logit, 4)))
print(paste("AUC no Teste - Probit:", round(auc_probit, 4)))
print(paste("AUC no Teste - Cauchit:", round(auc_cauchit, 4)))
# Classifica√ß√£o com limiar de 0.5
pred_logit <-
factor(ifelse(prob_logit > 0.5, "malignant", "benign"), levels = levels(teste_eng$Class))
# Matriz de Confus√£o para o modelo Logit
confusionMatrix(pred_logit, teste_eng$Class, positive = "malignant")
```
# Conclus√£o
O modelo Logit (fit_logit_2) se destacou como o melhor modelo. Ele n√£o s√≥ teve o menor AIC no conjunto de treino, indicando o melhor equil√≠brio entre ajuste e simplicidade, mas tamb√©m apresentou o maior valor de AUC (0.9765) no conjunto de teste, confirmando sua superior capacidade de generaliza√ß√£o e discrimina√ß√£o em dados n√£o vistos.
A matriz de confus√£o para o modelo Logit, usando um limiar padr√£o de 0.5, revela um bom desempenho:

* Acur√°cia: 92.34%

* Sensibilidade (Recall): 86.11%. Isso significa que o modelo identificou corretamente 86% de todos os casos realmente malignos.

* Especificidade: 95.62%. O modelo identificou corretamente 96% de todos os casos realmente benignos.

* Kappa de Cohen: 0.8282. Um valor alto, o que confirma que a performance do modelo √© superior √† de um palpite aleat√≥rio.

Com base nessas m√©tricas, o modelo Logit simplificado √© a escolha final para este problema, oferecendo alta performance, robustez e interpretabilidade.